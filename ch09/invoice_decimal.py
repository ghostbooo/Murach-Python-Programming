#!/usr/bin/env python3

from decimal import Decimal #Use of the "decimal module" as well as "importing the Decimal class" when working with decimal numbers that sometimes yield unexpected results due to floating-point numbers which also "approximate values". So, the more reliable way is using the decimal module that works with "Decimal numbers" which produces "exact values" and not approximate values. 
from decimal import ROUND_HALF_UP #Use of the "ROUND_HALF_UP" constant for the quantize() method that "rounds up" if the neighboring numbers are equidistant from the last digit of a decimal number. Note: On page 260, at the bottom of the page the value of "10.015" is supposed to be rounded up to (10.02) and not "10.01" which is incorrect in the Murach's Python book under the "ROUND_HALF_EVEN" rounding constant example. Because for the value "10.015", the 5 is preceded by a 1, which is an odd number. So, that means you round up to the nearest hundredth or whole number when working with decimal numbers.  
import locale as lc # Importing the "locale module into the lc namespace" to use for formatting the currency values as well as working with different locales. This is useful when formatting currency values that vary from one country to another.   

# display a title
print("The Invoice program")
print()

choice = "y"
while choice == "y":
    
    # get user entry
    order_total = Decimal(input("Enter order total:     ")) #Use of the "Decimal class" from the decimal module in which you use a "constructor" of the Decimal class to construct Decimal objects from "string values". You perform this by coding a set of parentheses after the Decimal class and then suupply the string for the decimal number within those parentheses. Note: This statement as a result takes the input of a string value and then converts it to a "Decimal object" which will later become a "decimal number". Pages: 260-261
    order_total = order_total.quantize(Decimal("1.00"), ROUND_HALF_UP) #Use of the "quantize method" of a "Decimal object" that rounds the decimal values to the specified number of decimal places. Here, in this statement you have the "order_total" variable representing the "object" piece inside of the quantize method. Next, you have the first argument of the quantize method which specifies a Decimal object that has the correct number of decimal places inside of the string. For this statement, in the Decimal("1.00") argument, you have 2 decimal places specified after the decimal of the string. Next, in the second argument of the quantize method, you have the rounding constant "ROUND_HALF_UP" specified. The "ROUND_HALF_UP" rounding constant "rounds up" if the neighboring numbers are equidistant. This is the rounding constant used in business math. Last, this rounding constant always "rounds up" regardless of whether the last number after the decimal is preceded by an odd or even number.   
    print()               

    # determine discount percent
    if order_total > 0 and order_total < 100: #Use of an "if statement" as well as the "AND" logical operator" to create a decimal number for the "discount percentage". This statement returns a "True" value only if both expressions are True. Note: Since the constructor of the Decimal class can't convert floating-point numbers to decimal numbers, this code uses "strings" to specify the "discount percentage as a decimal number". Pages: 262-263.
        discount_percent = Decimal("0")
    elif order_total >= 100 and order_total < 250: #Use of an "elif clause" as well as the "AND" logical operator" to create a decimal number for the "discount percentage". This statement returns a "True" value only if both expressions are True.   
        discount_percent = Decimal(".1")
    elif order_total >= 250: #Use of an "elif clause" to create a decimal number for the "discount percentage". This statement evaluates the Boolean expression. If the expression is "True" then the statement that follows is executed.   
        discount_percent = Decimal(".2")

    # calculate results
    discount = order_total * discount_percent
    discount = discount.quantize(Decimal("1.00"), ROUND_HALF_UP) #Use of the "quantize method" of a "Decimal object" that rounds the decimal values to the specified number of decimal places. Here, in this statement you have the "discount" variable representing the "object" piece inside of the quantize method. Next, you have the first argument of the quantize method which specifies a Decimal object that has the correct number of decimal places inside of the string. For this statement, in the Decimal("1.00") argument, you have 2 decimal places specified after the decimal of the string. Next, in the second argument of the quantize method, you have the rounding constant "ROUND_HALF_UP" specified. The "ROUND_HALF_UP" rounding constant "rounds up" if the neighboring numbers are equidistant. This is the rounding constant used in business math. In addition, this rounding constant always "rounds up" regardless of whether the last number after the decimal is preceded by an odd or even number. Last, the code uses the "quantize() method" to round the results to "two decimal positions" whenever a "multiplication" operation might yield a result that has more than 2 decimal places. All in all, this statement creates a "decimal number for the discount percentage" rounded up to 2 decimal places. Pages: 262-263.                                  
    subtotal = order_total - discount #This is a given to calculate. Note: See at the top of page 263 for the user interface to check correct results.
    shipping_percentage = Decimal(".085") #The "shipping percentage" value is a given calculation from question #3 on page 267. Note: This will create a "decimal number for the shipping percentage". 
    shipping_cost = subtotal * shipping_percentage #The "shipping cost" value is a given calculation from question #3 on page 267. This calculation is when you take the given "shipping percentage multiplied by the subtotal".
    shipping_cost = shipping_cost.quantize(Decimal("1.00"), ROUND_HALF_UP) #The "shipping cost" value is the given calculation when you take the "shipping percentage multiplied by the substotal". In addition, this will create a decimal number for the "shipping cost" rounded up to 2 decimal places. Note: See pages 262-263 and 267.
    tax_percent = Decimal(".05") #Use of a given "tax percentage" that takes advantage of the constructor of the Decimal class which uses the "string" inside of the code statement to specifiy the "tax percentage as a decimal number". Last, this value will result in 2 decimal places as specified in the given string. Note: See pages 262-263. 
    sales_tax = subtotal * tax_percent #Use of a given "sales tax" value that takes the "subtotal multiplied by the tax percentage". Note: See pages 262-263.
    sales_tax = sales_tax.quantize(Decimal("1.00"), ROUND_HALF_UP) #Use of the "quantize method" of a "Decimal object" that rounds the decimal values to the specified number of decimal places. Here, in this statement you have the "sales tax" variable representing the "object" piece inside of the quantize method. Next, you have the first argument of the quantize method which specifies a Decimal object that has the correct number of decimal places inside of the string. For this statement, in the Decimal("1.00") argument, you have 2 decimal places specified after the decimal of the string. Next, in the second argument of the quantize method, you have the rounding constant "ROUND_HALF_UP" specified. The "ROUND_HALF_UP" rounding constant "rounds up" if the neighboring numbers are equidistant. This is the rounding constant used in business math. In addition, this rounding constant always "rounds up" regardless of whether the last number after the decimal is preceded by an odd or even number. Last, the code uses the "quantize() method" to round the results to "two decimal positions" whenever a "multiplication" operation might yield a result that has more than 2 decimal places. All in all, this statement creates a "decimal number for the sales tax" rounded up to 2 decimal places. Pages: 262-263.                              
    invoice_total = subtotal + shipping_cost + sales_tax #Use of a given "invoice total" value that takes the "subtotal plus shipping cost plus the sales tax". Note: See pages 262-263 and user interface at the top of page 267. 
 
    # display the results
    lc.setlocale(lc.LC_ALL, "us")       #Use of the "setlocale() function" that sets the locale for the specified "category" to the "locale" for the specified country code and returns a string for the locale. If "category" is set to "LC_ALL", the locale is applied to all categories for the first argument. The second argument for the "setlocale() function" is a code that specifies the locale that should be used for formatting. In this case, "us" is used as the locale for the "setlocale() function" that sets the locale to English/United States that works on most "Windows systems". Last, if you use an empty string "" as the second argument for the locale, Python attempts to use the default locale for the user's computer to adjust for any timezone the user's located in.  Note: Pages: 256-257.
    #lc.setlocale(lc.LC_ALL, "en_US") #Use of the "setlocale() function" that sets the locale to English/United States as default for most Mac/OS X systems.
    print("Order total:      {:>11}".format(lc.currency(order_total, grouping=True))) #Use of a "print() function" that utilizes a nested "currency() function inside of a format() method". Here, you have the "formaat() method" to format the "Order Total" amount by passing one value to the specification of the string. In this case, you're taking the "{:>11}" format specification and passing a value into the "string" which will become the user's entry for the "Order Total". Next, you have the use of the "currency() function" that formats specific value. For this function, the first argument specifies the monetary value and is the only required argument. But there is an optional "grouping" argument set to the value of "True" to separate the thousands in large numbers. What this code statement does is display a right alignment in the appropriate column of the "Order Total" entry "11 character spaces to the right" and separates the thousands in large numbers by using "commas". Note: Pages 254-255, 256-257 and 264-265.
    print("Discount amount:  {:11,}".format(discount)) #Use of the "print() function" that displays the "Discount amount". Nested inside of the "print() function" is the "format() method" that specifies a field width of "11" according to the string specification that will result as the "Discount amount" entry in the appropriate column. Also, "{:11}" format specification represents a "left alignment" in the first column by default because there's only "one string specification" listed in this "print() function" denoted by the one set of curly braces. Note: For reference, the format specification, which is a string is then followed by a period and the "format() method" of the string. The "argument" for this method is the value to be formatted. In this case, the argument "discount" is passed to the "format() method" to be formatted. Pages 254-255 and 264-265. 
    print("Subtotal:         {:11,}".format(subtotal)) #Use of the "print() function" that displays the "Subtotal". Nested inside of the "print() function" is the "format() method" that specifies a field width of "11" according to the string specification that will result as the "Subtotal" entry in the appropriate column. Also, "{:11}" format specification represents a "left alignment" in the first column by default because there's only "one string specification" listed in this "print() function" denoted by the one set of curly braces. Note: For reference, the format specification, which is a string is then followed by a period and the "format() method" of the string. The "argument" for this method is the value to be formatted. In this case, the argument "subtotal" is passed to the "format() method" to be formatted. Pages 254-255 and 264-265. 
    print("Shipping cost:    {:11,}".format(shipping_cost)) #Use of the "print() function" that displays the "Shipping cost". Nested inside of the "print() function" is the "format() method" that specifies a field width of "11" according to the string specification that will result as the "Shipping cost" entry in the appropriate column. Also, "{:11}" format specification represents a "left alignment" in the first column by default because there's only "one string specification" listed in this "print() function" denoted by the one set of curly braces. Note: For reference, the format specification, which is a string is then followed by a period and the "format() method" of the string. The "argument" for this method is the value to be formatted. In this case, the argument "shipping_cost" is passed to the "format() method" to be formatted. Pages 254-255 and 264-265. 
    print("Sales tax:        {:11,}".format(sales_tax)) #Use of the "print() function" that displays the "Sales tax". Nested inside of the "print() function" is the "format() method" that specifies a field width of "11" according to the string specification that will result as the "Sales tax" entry in the appropriate column. Also, "{:11}" format specification represents a "left alignment" in the first column by default because there's only "one string specification" listed in this "print() function" denoted by the one set of curly braces. Note: For reference, the format specification, which is a string is then followed by a period and the "format() method" of the string. The "argument" for this method is the value to be formatted. In this case, the argument "sales_tax" is passed to the "format() method" to be formatted. Pages 254-255 and 264-265. 
    print("Invoice total:    {:>11}".format(lc.currency(invoice_total, grouping=True))) #Use of a "print() function" that utilizes a nested "currency() function inside of a format() method". Here, you have the "formaat() method" to format the "Invoice Total" amount by passing one value to the specification of the string. In this case, you're taking the "{:>11}" format specification and passing a value into the "string" which will become the user's entry for the "Invoice Total". Next, you have the use of the "currency() function" that formats specific value. For this function, the first argument specifies the monetary value and is the only required argument. But there is an optional "grouping" argument set to the value of "True" to separate the thousands in large numbers. What this code statement does is display a right alignment in the appropriate column of the "Invoice Total" entry "11 character spaces to the right" and separates the thousands in large numbers by using "commas". Note: Pages 254-255, 256-257 and 264-265.
    print()

    choice = input("Continue? (y/n): ")    
    print()
    
print("Bye")
